t.num <- 2 * sqrt(d**2 + (tan(solar.zn.at) * tan(sensor.zn.at) * sin(relative.az)) ** 2)
t.denom <- (1 / cos(solar.zn.at)) + (1 / cos(sensor.zn.at))
t <- acos(pmax(pmin((t.num/t.denom), 1.0), -1.0))
# next we need to use Eq 33,48. Wanner et al. JGRA 1995
o <- (1 / pi) * (t - sin(t) * cos(t)) * t.denom
# next we need to use Eq 51. Wanner et al. JGRA 1995
cos.phase <- cos(solar.zn.at) * cos(sensor.zn.at) + sin(solar.zn.at) * sin(sensor.zn.at) * cos(relative.az)
# for the Sparse Li Kernel - Eq 32. Wanner et al. JGRA 1995
li.sparse <- o - (1 / cos(solar.zn.at)) - (1 / cos(sensor.zn.at)) + 0.5 * (1 + cos.phase) * (1 / cos(sensor.zn.at))
# for the Dense Li Kernel - Eq 47. Wanner et al. JGRA 1995
li.dense <- (((1 + cos.phase) * (1 / cos(sensor.zn.at))) / (t.denom - o)) - 2
# first we need to implement Eq. 37,52. Wanner et al. JGRA 1995
solar.zn.at <- atan(10 * tan(solar.zn))
sensor.zn.at <- atan(10 * tan(0))
# next we need to use Eq 50. Wanner et al. JGRA 1995
d <- sqrt((tan(solar.zn.at) ** 2) + (tan(sensor.zn.at) ** 2) - (2 * tan(solar.zn.at) * tan(sensor.zn.at) * cos(relative.az)))
t.num <- sqrt(d**2 + (tan(solar.zn.at) * tan(sensor.zn.at) * sin(relative.az) ** 2))
t.denom <- (1 / cos(solar.zn.at)) + (1 / cos(sensor.zn.at))
t <- acos(pmax(pmin((2*(t.num/t.denom)), 1.0), -1.0))
# next we need to use Eq 33,48. Wanner et al. JGRA 1995
o <- (1 / pi) * (t - sin(t) * cos(t)) * t.denom
# next we need to use Eq 51. Wanner et al. JGRA 1995
cos.phase <- cos(solar.zn.at) * cos(sensor.zn.at) + sin(solar.zn.at) * sin(sensor.zn.at) * cos(relative.az)
# for the Sparse Li Kernel - Eq 32. Wanner et al. JGRA 1995
li.sparse.nad <- o - (1 / cos(solar.zn.at)) - (1 / cos(sensor.zn.at)) + 0.5 * (1 + cos.phase) * (1 / cos(sensor.zn.at))
# for the Dense Li Kernel - Eq 47. Wanner et al. JGRA 1995
li.dense.nad <- (((1 + cos.phase) * (1 / cos(sensor.zn.at))) / (t.denom - o)) - 2
gc()
rm(cos.phase)
rm(d)
rm(o)
rm(phase)
rm(phase.nad)
rm(relative.az)
rm(sensor.az)
rm(sensor.zn)
rm(t)
rm(t.num)
gc()
# lets apply the NDVI and brightness masks to the kernals based on which kernals we want to use
if (ross == "thick"){
print("Using thick ross.")
ross.mask <- ifelse(ndvi.mask, ross.thick, NA)
ross.mask <- ifelse(brightness.mask, ross.mask, NA)
ross.mask.n <- ifelse(ndvi.mask, ross.thick.nad, NA)
ross.mask.n <- ifelse(brightness.mask, ross.mask.n, NA)
}
if (ross == "thin"){
print("Using thin ross.")
ross.mask <- ifelse(ndvi.mask, ross.thin, NA)
ross.mask <- ifelse(brightness.mask, ross.mask, NA)
ross.mask.n <- ifelse(ndvi.mask, ross.thin.nad, NA)
ross.mask.n <- ifelse(brightness.mask, ross.mask.n, NA)
}
if(li == "dense"){
print("Using dense li.")
li.mask <- ifelse(ndvi.mask, li.dense, NA)
li.mask <- ifelse(brightness.mask, li.mask, NA)
li.mask.n <- ifelse(ndvi.mask, li.dense.nad, NA)
li.mask.n <- ifelse(brightness.mask, li.mask.n, NA)
}
if(li == "sparse"){
print("Using sparse li.")
li.mask <- ifelse(ndvi.mask, li.sparse, NA)
li.mask <- ifelse(brightness.mask, li.mask, NA)
li.mask.n <- ifelse(ndvi.mask, li.sparse.nad, NA)
li.mask.n <- ifelse(brightness.mask, li.mask.n, NA)
}
# lets transform the data into the appropriate shape for regression
ross <- matrix(ross.mask, nrow = length(ross.mask), ncol = 1)
li <- matrix(li.mask, nrow = length(li.mask), ncol = 1)
# lets column bind the data we need together
x.brdf <- cbind(ross, li)
# lets prevent R from writing the numbers in scientific format
options(scipen = 999)
# lets read in the shapefile
toc.refl <- readOGR(shp.file.loc,
shp.file.name)
# we need to make an empty matrix to store all the reflectance data in
ext.mat <- matrix(ncol = length(band.combo) + 2,
nrow = nrow(toc.refl) + 1)
# set the wavelength names
wl.names <- paste0("nm", wavelengths[band.combo])
# set the column names
ext.mat[1,1] <- "ID"
ext.mat[1,2] <- "Fline"
ext.mat[1, 3:ncol(ext.mat)] <- wl.names
# make sure that the column variable is correctly named
colnames(toc.refl@data) <- "ID"
# set the ID variable
ext.mat[2:nrow(ext.mat), 1] <- as.vector(toc.refl@data$ID)
# pull out the file name
clean.name <- tools::file_path_sans_ext(hy.file)
clean.name <- strsplit(clean.name, "/")[[1]][4]
ext.mat[2:nrow(ext.mat), 2] <- strsplit(clean.name, "_")[[1]][6]
# set the index for the matrix column
r <- 3
# read in the coordinate infomation
map.info <- h5read(file = hy.file,
name = coordinate.path)
# save the crs projection data
crs.proj <- base::paste0("+init=epsg:", map.info$`EPSG Code`)
# pull out the map extent info
map.info <- strsplit(map.info$Map_Info, split = ",", fixed = TRUE)
x.min <- as.numeric(map.info[[1]][4])
y.max <- as.numeric(map.info[[1]][5])
# memory clean up
gc()
# memory clean up
gc()
rm(aspect)
rm(brightness)
rm(cosine.i)
rm(li)
rm(li.dense)
rm(li.dense.nad)
rm(li.sparse)
rm(li.sparse.nad)
rm(ndvi)
rm(rel.az)
rm(ross)
rm(ross.thick)
rm(ross.thick.nad)
rm(ross.thin)
rm(ross.thin.nad)
rm(slope)
gc()
q <- 25
print(paste0("applying topographic correction to band ", q, "."))
# lets read in the band and clean it up like we need before
refl.array <- h5read(file = hy.file,
name = reflectance.path,
index = list(q, 1:n.cols, 1:n.rows))
refl.matrix <- refl.array[1,,]
refl.matrix[refl.matrix == data.ignore.val] <- NA
refl.matrix <- refl.matrix / scale.fact.val
# memory clean up
gc()
rm(refl.array)
gc()
# lets apply the masks to this band
refl.matrix <- ifelse(ndvi.mask, refl.matrix, NA)
# lets transform the data into the appropriate shape for regression
y <- matrix(refl.matrix, nrow = length(refl.matrix), ncol = 1)
# lets run the regression now: # Eq 7. Soenen et al., IEEE TGARS 2005
topo.lm <- lm(y ~ x.topo)
# lets save the coefficients
topo.coef <- topo.lm$coefficients
# Eq 8. Soenen et al., IEEE TGARS 2005
if (topo.coef[[2]] == 0){
c <- 0
} else {
c <- topo.coef[[1]] / topo.coef[[2]]
}
# find correction factor - Eq 11. Soenen et al., IEEE TGARS 2005
cor.fact <- (c1 + c) / (cosine.i.mask + c)
# apply the correction factor
topo.cor <- refl.matrix * cor.fact
gc()
rm(topo.lm)
rm(refl.matrix)
rm(cor.fact)
gc()
print(paste0("applying brdf correction to band ", q, "."))
# lets apply the brightness mask to this topo corrected band
topo.matrix <- ifelse(brightness.mask, topo.cor, NA)
# lets transform the data into the appropriate shape for regression
y <- matrix(topo.matrix, nrow = length(topo.matrix), ncol = 1)
# lets run the regression now
brdf.lm <- lm(y ~ x.brdf)
# lets save the coefficients
brdf.coef <- brdf.lm$coefficients
# now lets apply the coefficients to the band - eq 5. Weyermann et al. IEEE-TGARS 2015
brdf <- brdf.coef[[1]] + (li.mask * brdf.coef[[3]]) + (ross.mask * brdf.coef[[2]])
brdf.nad <- brdf.coef[[1]] + (li.mask.n * brdf.coef[[3]]) + (ross.mask.n * brdf.coef[[2]])
# lets find the correction factor: eq 4. Weyermann et al. IEEE-TGARS 2015
brdf.cor <- brdf.nad / brdf
# lets apply the correction factor to the band
band.brdf <- topo.matrix * brdf.cor
gc()
rm(topo.matrix)
rm(brdf.cor)
rm(topo.cor)
rm(brdf.lm)
gc()
# memory management
gc()
rm(y)
gc()
rm(brdf)
rm(brdf.nad)
rm(band.brdf)
gc()
library(devtools)
library(roxygen2)
setwd("C:/Users/Aaron Kamoske/Dropbox/R_Packages_GitHub/hypRspec")
devtools::document()
install_github("akamoske/hypRspec")
q
print(paste0("applying topographic correction to band ", q, "."))
# lets read in the band and clean it up like we need before
refl.array <- h5read(file = hy.file,
name = reflectance.path,
index = list(q, 1:n.cols, 1:n.rows))
refl.matrix <- refl.array[1,,]
print(paste0("applying topographic correction to band ", q, "."))
# lets read in the band and clean it up like we need before
refl.array <- h5read(file = hy.file,
name = reflectance.path,
index = list(q, 1:n.cols, 1:n.rows))
refl.matrix <- refl.array[1,,]
refl.matrix[refl.matrix == data.ignore.val] <- NA
refl.matrix <- refl.matrix / scale.fact.val
# memory clean up
gc()
rm(refl.array)
gc()
# lets apply the masks to this band
refl.matrix <- ifelse(ndvi.mask, refl.matrix, NA)
# lets transform the data into the appropriate shape for regression
y <- matrix(refl.matrix, nrow = length(refl.matrix), ncol = 1)
# lets run the regression now: # Eq 7. Soenen et al., IEEE TGARS 2005
topo.lm <- lm(y ~ x.topo)
# lets save the coefficients
topo.coef <- topo.lm$coefficients
# Eq 8. Soenen et al., IEEE TGARS 2005
if (topo.coef[[2]] == 0){
c <- 0
} else {
c <- topo.coef[[1]] / topo.coef[[2]]
}
# find correction factor - Eq 11. Soenen et al., IEEE TGARS 2005
cor.fact <- (c1 + c) / (cosine.i.mask + c)
# apply the correction factor
topo.cor <- refl.matrix * cor.fact
#---------------------------------------------------------------------------------------------------
# lets clear up some memory before applying the brdf correction
#---------------------------------------------------------------------------------------------------
gc()
rm(topo.lm)
rm(refl.matrix)
rm(cor.fact)
gc()
#---------------------------------------------------------------------------------------------------
# lets apply the brdf correction to the topo corrected band
#---------------------------------------------------------------------------------------------------
print(paste0("applying brdf correction to band ", q, "."))
# lets apply the brightness mask to this topo corrected band
topo.matrix <- ifelse(brightness.mask, topo.cor, NA)
# lets transform the data into the appropriate shape for regression
y <- matrix(topo.matrix, nrow = length(topo.matrix), ncol = 1)
# lets run the regression now
brdf.lm <- lm(y ~ x.brdf)
# memory management
gc()
rm(y)
gc()
# lets save the coefficients
brdf.coef <- brdf.lm$coefficients
# now lets apply the coefficients to the band - eq 5. Weyermann et al. IEEE-TGARS 2015
brdf <- brdf.coef[[1]] + (li.mask * brdf.coef[[3]]) + (ross.mask * brdf.coef[[2]])
brdf.nad <- brdf.coef[[1]] + (li.mask.n * brdf.coef[[3]]) + (ross.mask.n * brdf.coef[[2]])
# lets find the correction factor: eq 4. Weyermann et al. IEEE-TGARS 2015
brdf.cor <- brdf.nad / brdf
# lets apply the correction factor to the band
band.brdf <- topo.matrix * brdf.cor
#---------------------------------------------------------------------------------------------------
# lets clear up some memory before applying the brdf correction
#---------------------------------------------------------------------------------------------------
gc()
rm(topo.matrix)
rm(brdf)
rm(brdf.nad)
rm(brdf.cor)
rm(topo.cor)
rm(brdf.lm)
gc()
#---------------------------------------------------------------------------------------------------
# lets make a raster
#---------------------------------------------------------------------------------------------------
print(paste0("extracting data from band ", q, "."))
# convert the matrix to a raster
refl.raster <- raster(band.brdf, crs = crs.proj)
# we need to transpose the raster
refl.raster <- raster::t(refl.raster)
# find the dimensions of our raster
y.dim <- dim(refl.raster)[1]
x.dim <- dim(refl.raster)[2]
# set the x.max and y.min
x.max <- x.min + x.dim
y.min <- y.max - y.dim
# create an extent object
raster.ext <- extent(x.min, x.max, y.min, y.max)
# set the spatial extent of the raster
extent(refl.raster) <- raster.ext
# lets extract the reflectance data
ref.toc <- extract(x = refl.raster,
y = toc.refl,
method = "simple")
# lets add this into the right part of the matrix
ext.mat[2:nrow(ext.mat), r] <- ref.toc
# set the matrix index
r <- r + 1
#---------------------------------------------------------------------------------------------------
# lets clear up some memory before making rasters
#---------------------------------------------------------------------------------------------------
gc()
rm(refl.raster)
rm(band.brdf)
gc()
print(paste0("applying topographic correction to band ", q, "."))
# lets read in the band and clean it up like we need before
refl.array <- h5read(file = hy.file,
name = reflectance.path,
index = list(q, 1:n.cols, 1:n.rows))
refl.matrix <- refl.array[1,,]
refl.matrix[refl.matrix == data.ignore.val] <- NA
refl.matrix <- refl.matrix / scale.fact.val
# memory clean up
gc()
rm(refl.array)
gc()
# lets apply the masks to this band
refl.matrix <- ifelse(ndvi.mask, refl.matrix, NA)
# lets transform the data into the appropriate shape for regression
y <- matrix(refl.matrix, nrow = length(refl.matrix), ncol = 1)
# lets run the regression now: # Eq 7. Soenen et al., IEEE TGARS 2005
topo.lm <- lm(y ~ x.topo)
# lets save the coefficients
topo.coef <- topo.lm$coefficients
# Eq 8. Soenen et al., IEEE TGARS 2005
if (topo.coef[[2]] == 0){
c <- 0
} else {
c <- topo.coef[[1]] / topo.coef[[2]]
}
# find correction factor - Eq 11. Soenen et al., IEEE TGARS 2005
cor.fact <- (c1 + c) / (cosine.i.mask + c)
# apply the correction factor
topo.cor <- refl.matrix * cor.fact
#---------------------------------------------------------------------------------------------------
# lets clear up some memory before applying the brdf correction
#---------------------------------------------------------------------------------------------------
gc()
rm(topo.lm)
rm(refl.matrix)
rm(cor.fact)
gc()
#---------------------------------------------------------------------------------------------------
# lets apply the brdf correction to the topo corrected band
#---------------------------------------------------------------------------------------------------
print(paste0("applying brdf correction to band ", q, "."))
# lets apply the brightness mask to this topo corrected band
topo.matrix <- ifelse(brightness.mask, topo.cor, NA)
# lets transform the data into the appropriate shape for regression
y <- matrix(topo.matrix, nrow = length(topo.matrix), ncol = 1)
# lets run the regression now
brdf.lm <- lm(y ~ x.brdf)
# memory management
gc()
rm(y)
gc()
# lets save the coefficients
brdf.coef <- brdf.lm$coefficients
# now lets apply the coefficients to the band - eq 5. Weyermann et al. IEEE-TGARS 2015
brdf <- brdf.coef[[1]] + (li.mask * brdf.coef[[3]]) + (ross.mask * brdf.coef[[2]])
brdf.nad <- brdf.coef[[1]] + (li.mask.n * brdf.coef[[3]]) + (ross.mask.n * brdf.coef[[2]])
# lets find the correction factor: eq 4. Weyermann et al. IEEE-TGARS 2015
brdf.cor <- brdf.nad / brdf
# lets apply the correction factor to the band
band.brdf <- topo.matrix * brdf.cor
#---------------------------------------------------------------------------------------------------
# lets clear up some memory before applying the brdf correction
#---------------------------------------------------------------------------------------------------
gc()
rm(topo.matrix)
rm(brdf)
rm(brdf.nad)
rm(brdf.cor)
rm(topo.cor)
rm(brdf.lm)
gc()
#---------------------------------------------------------------------------------------------------
# lets make a raster
#---------------------------------------------------------------------------------------------------
print(paste0("extracting data from band ", q, "."))
# convert the matrix to a raster
refl.raster <- raster(band.brdf, crs = crs.proj)
# we need to transpose the raster
refl.raster <- raster::t(refl.raster)
# find the dimensions of our raster
y.dim <- dim(refl.raster)[1]
x.dim <- dim(refl.raster)[2]
# set the x.max and y.min
x.max <- x.min + x.dim
y.min <- y.max - y.dim
# create an extent object
raster.ext <- extent(x.min, x.max, y.min, y.max)
# set the spatial extent of the raster
extent(refl.raster) <- raster.ext
# lets extract the reflectance data
ref.toc <- extract(x = refl.raster,
y = toc.refl,
method = "simple")
# lets add this into the right part of the matrix
ext.mat[2:nrow(ext.mat), r] <- ref.toc
# set the matrix index
r <- r + 1
#---------------------------------------------------------------------------------------------------
# lets clear up some memory before making rasters
#---------------------------------------------------------------------------------------------------
gc()
rm(refl.raster)
rm(band.brdf)
gc()
q
ext.mat
ext.mat[,3]
q <- 26
print(paste0("applying topographic correction to band ", q, "."))
# lets read in the band and clean it up like we need before
refl.array <- h5read(file = hy.file,
name = reflectance.path,
index = list(q, 1:n.cols, 1:n.rows))
refl.matrix <- refl.array[1,,]
refl.matrix[refl.matrix == data.ignore.val] <- NA
refl.matrix <- refl.matrix / scale.fact.val
# memory clean up
gc()
rm(refl.array)
gc()
# lets apply the masks to this band
refl.matrix <- ifelse(ndvi.mask, refl.matrix, NA)
# lets transform the data into the appropriate shape for regression
y <- matrix(refl.matrix, nrow = length(refl.matrix), ncol = 1)
# lets run the regression now: # Eq 7. Soenen et al., IEEE TGARS 2005
topo.lm <- lm(y ~ x.topo)
# lets save the coefficients
topo.coef <- topo.lm$coefficients
# Eq 8. Soenen et al., IEEE TGARS 2005
if (topo.coef[[2]] == 0){
c <- 0
} else {
c <- topo.coef[[1]] / topo.coef[[2]]
}
# find correction factor - Eq 11. Soenen et al., IEEE TGARS 2005
cor.fact <- (c1 + c) / (cosine.i.mask + c)
# apply the correction factor
topo.cor <- refl.matrix * cor.fact
gc()
rm(topo.lm)
rm(refl.matrix)
rm(cor.fact)
gc()
print(paste0("applying brdf correction to band ", q, "."))
# lets apply the brightness mask to this topo corrected band
topo.matrix <- ifelse(brightness.mask, topo.cor, NA)
# lets transform the data into the appropriate shape for regression
y <- matrix(topo.matrix, nrow = length(topo.matrix), ncol = 1)
# lets run the regression now
brdf.lm <- lm(y ~ x.brdf)
# memory management
gc()
rm(y)
gc()
# lets save the coefficients
brdf.coef <- brdf.lm$coefficients
# now lets apply the coefficients to the band - eq 5. Weyermann et al. IEEE-TGARS 2015
brdf <- brdf.coef[[1]] + (li.mask * brdf.coef[[3]]) + (ross.mask * brdf.coef[[2]])
brdf.nad <- brdf.coef[[1]] + (li.mask.n * brdf.coef[[3]]) + (ross.mask.n * brdf.coef[[2]])
# lets find the correction factor: eq 4. Weyermann et al. IEEE-TGARS 2015
brdf.cor <- brdf.nad / brdf
# lets apply the correction factor to the band
band.brdf <- topo.matrix * brdf.cor
gc()
rm(topo.matrix)
rm(brdf)
rm(brdf.nad)
rm(brdf.cor)
rm(topo.cor)
rm(brdf.lm)
gc()
print(paste0("extracting data from band ", q, "."))
# convert the matrix to a raster
refl.raster <- raster(band.brdf, crs = crs.proj)
# we need to transpose the raster
refl.raster <- raster::t(refl.raster)
# find the dimensions of our raster
y.dim <- dim(refl.raster)[1]
x.dim <- dim(refl.raster)[2]
# set the x.max and y.min
x.max <- x.min + x.dim
y.min <- y.max - y.dim
# create an extent object
raster.ext <- extent(x.min, x.max, y.min, y.max)
# set the spatial extent of the raster
extent(refl.raster) <- raster.ext
# lets extract the reflectance data
ref.toc <- extract(x = refl.raster,
y = toc.refl,
method = "simple")
# lets add this into the right part of the matrix
ext.mat[2:nrow(ext.mat), r] <- ref.toc
# set the matrix index
r <- r + 1
gc()
rm(refl.raster)
rm(band.brdf)
gc()
ext.mat[,2]
ext.mat[,1]
ext.mat[,3]
